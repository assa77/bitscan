; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	D:\WORK\bitscan\bitscan\bitscan.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG46984 DB	0aH, 'BitScan - Copyright (c) 2019 by Alexander M. Albert'
	DB	'ian <assa@4ip.ru>.', 0aH, 'All rights reserved.', 0aH, 0aH, 00H
	ORG $+2
$SG46985 DB	'__WORDSIZE', 00H
	ORG $+1
$SG46986 DB	'%-12s : %lu', 0aH, 00H
	ORG $+3
$SG46987 DB	'_IS_X86', 00H
$SG46988 DB	'%-12s : %lu', 0aH, 00H
	ORG $+3
$SG46989 DB	'_IS_386', 00H
$SG46990 DB	'%-12s : %lu', 0aH, 00H
	ORG $+3
$SG46991 DB	0aH, 'Input unsigned integer> ', 00H
	ORG $+2
$SG46992 DB	'%llu', 00H
	ORG $+3
$SG46993 DB	0aH, '32-bit input value: %lu', 0aH, 00H
	ORG $+2
$SG46994 DB	'_BSR32( %lu ): %u (Success=%u)', 0aH, 00H
$SG46995 DB	'_BSF32( %lu ): %u (Success=%u)', 0aH, 00H
$SG46996 DB	0aH, '64-bit input value: %llu', 0aH, 00H
	ORG $+1
$SG46997 DB	'_BSR64( %llu ): %u (Success=%u)', 0aH, 00H
	ORG $+3
$SG46998 DB	'_BSF64( %llu ): %u (Success=%u)', 0aH, 00H
CONST	ENDS
PUBLIC	__InlineBitScanForward64
PUBLIC	__InlineBitScanReverse64
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	__vfprintf_l
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	__vfscanf_l
PUBLIC	_scanf
PUBLIC	_main
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
EXTRN	___acrt_iob_func:PROC
EXTRN	_fputs:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vfscanf:PROC
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
; Function compile flags: /Ogtpy
; File d:\work\bitscan\bitscan\bitscan.cpp
_TEXT	SEGMENT
_r$1 = -16						; size = 4
_r$2 = -12						; size = 4
_input$ = -8						; size = 8
_main	PROC

; 44   : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	56		 push	 esi

; 45   : 	unsigned long long input;
; 46   : 	unsigned result;
; 47   : 	unsigned status;
; 48   : 
; 49   : 	fputs( "\nBitScan - Copyright (c) 2019 by Alexander M. Albertian <assa@4ip.ru>.\nAll rights reserved.\n\n", stdout );

  00004	6a 01		 push	 1
  00006	e8 00 00 00 00	 call	 ___acrt_iob_func
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET $SG46984
  00011	e8 00 00 00 00	 call	 _fputs

; 50   : 
; 51   : 	PRINTM( __WORDSIZE );

  00016	6a 20		 push	 32			; 00000020H
  00018	68 00 00 00 00	 push	 OFFSET $SG46985
  0001d	68 00 00 00 00	 push	 OFFSET $SG46986
  00022	e8 00 00 00 00	 call	 _printf

; 52   : 
; 53   : #ifdef _IS_X86
; 54   : 	PRINTM( _IS_X86 );

  00027	6a 01		 push	 1
  00029	68 00 00 00 00	 push	 OFFSET $SG46987
  0002e	68 00 00 00 00	 push	 OFFSET $SG46988
  00033	e8 00 00 00 00	 call	 _printf

; 55   : #endif
; 56   : #ifdef _IS_386
; 57   : 	PRINTM( _IS_386 );

  00038	6a 01		 push	 1
  0003a	68 00 00 00 00	 push	 OFFSET $SG46989
  0003f	68 00 00 00 00	 push	 OFFSET $SG46990
  00044	e8 00 00 00 00	 call	 _printf

; 58   : #endif
; 59   : #ifdef _IS_X64
; 60   : 	PRINTM( _IS_X64 );
; 61   : #endif
; 62   : #ifdef _IS_ARM
; 63   : 	PRINTM( _IS_ARM );
; 64   : #endif
; 65   : #ifdef _IS_THUMB
; 66   : 	PRINTM( _IS_THUMB );
; 67   : #endif
; 68   : #ifdef _IS_IN_THUMB
; 69   : 	PRINTM( _IS_IN_THUMB );
; 70   : #endif
; 71   : #ifdef _IS_ARM64
; 72   : 	PRINTM( _IS_ARM64 );
; 73   : #endif
; 74   : #ifdef _IS_NEON
; 75   : 	PRINTM( _IS_NEON );
; 76   : #endif
; 77   : 
; 78   : 	fputs( "\nInput unsigned integer> ", stdout );

  00049	6a 01		 push	 1
  0004b	e8 00 00 00 00	 call	 ___acrt_iob_func
  00050	50		 push	 eax
  00051	68 00 00 00 00	 push	 OFFSET $SG46991
  00056	e8 00 00 00 00	 call	 _fputs

; 79   : 	scanf( "%llu", &input );

  0005b	8d 44 24 48	 lea	 eax, DWORD PTR _input$[esp+80]
  0005f	50		 push	 eax
  00060	68 00 00 00 00	 push	 OFFSET $SG46992
  00065	e8 00 00 00 00	 call	 _scanf
  0006a	83 c4 44	 add	 esp, 68			; 00000044H

; 80   : 
; 81   : 	printf( "\n32-bit input value: %lu\n", ( unsigned long )( uint32_t )input );

  0006d	ff 74 24 0c	 push	 DWORD PTR _input$[esp+20]
  00071	68 00 00 00 00	 push	 OFFSET $SG46993
  00076	e8 00 00 00 00	 call	 _printf

; 82   : #ifdef _IS_BITSCANR32
; 83   : 	status = _BSR32( &result, ( uint32_t )input );

  0007b	8b 4c 24 14	 mov	 ecx, DWORD PTR _input$[esp+28]
  0007f	0f bd c1	 bsr	 eax, ecx
  00082	89 44 24 0c	 mov	 DWORD PTR _r$1[esp+28], eax
  00086	0f 95 c0	 setne	 al
  00089	0f b6 c0	 movzx	 eax, al

; 84   : 	printf( "_BSR32( %lu ): %u (Success=%u)\n", ( unsigned long )( uint32_t )input, result, status );

  0008c	50		 push	 eax
  0008d	ff 74 24 10	 push	 DWORD PTR _r$1[esp+32]
  00091	51		 push	 ecx
  00092	68 00 00 00 00	 push	 OFFSET $SG46994
  00097	e8 00 00 00 00	 call	 _printf

; 85   : #endif
; 86   : #ifdef _IS_BITSCANF32
; 87   : 	status = _BSF32( &result, ( uint32_t )input );

  0009c	8b 4c 24 24	 mov	 ecx, DWORD PTR _input$[esp+44]
  000a0	0f bc c1	 bsf	 eax, ecx
  000a3	89 44 24 20	 mov	 DWORD PTR _r$2[esp+44], eax
  000a7	0f 95 c0	 setne	 al
  000aa	0f b6 c0	 movzx	 eax, al

; 88   : 	printf( "_BSF32( %lu ): %u (Success=%u)\n", ( unsigned long )( uint32_t )input, result, status );

  000ad	50		 push	 eax
  000ae	ff 74 24 24	 push	 DWORD PTR _r$2[esp+48]
  000b2	51		 push	 ecx
  000b3	68 00 00 00 00	 push	 OFFSET $SG46995
  000b8	e8 00 00 00 00	 call	 _printf

; 89   : #endif
; 90   : #ifdef _IS_BITSCAN64
; 91   : 	printf( "\n64-bit input value: %llu\n", input );

  000bd	ff 74 24 38	 push	 DWORD PTR _input$[esp+64]
  000c1	ff 74 24 38	 push	 DWORD PTR _input$[esp+64]
  000c5	68 00 00 00 00	 push	 OFFSET $SG46996
  000ca	e8 00 00 00 00	 call	 _printf

; 92   : 	status = _BSR64( &result, input );

  000cf	8b 74 24 44	 mov	 esi, DWORD PTR _input$[esp+76]
  000d3	83 c4 34	 add	 esp, 52			; 00000034H
  000d6	0f bd ce	 bsr	 ecx, esi
  000d9	8b 54 24 0c	 mov	 edx, DWORD PTR _input$[esp+20]
  000dd	74 0a		 je	 SHORT $LN10@main
  000df	83 c1 20	 add	 ecx, 32			; 00000020H
  000e2	b8 01 00 00 00	 mov	 eax, 1
  000e7	eb 0b		 jmp	 SHORT $LN11@main
$LN10@main:
  000e9	0f bd ca	 bsr	 ecx, edx
  000ec	b8 00 00 00 00	 mov	 eax, 0
  000f1	0f 95 c0	 setne	 al
$LN11@main:

; 93   : 	printf( "_BSR64( %llu ): %u (Success=%u)\n", input, result, status );

  000f4	50		 push	 eax
  000f5	51		 push	 ecx
  000f6	56		 push	 esi
  000f7	52		 push	 edx
  000f8	68 00 00 00 00	 push	 OFFSET $SG46997
  000fd	e8 00 00 00 00	 call	 _printf

; 94   : 	status = _BSF64( &result, input );

  00102	8b 74 24 20	 mov	 esi, DWORD PTR _input$[esp+40]
  00106	83 c4 14	 add	 esp, 20			; 00000014H
  00109	0f bc c6	 bsf	 eax, esi
  0010c	8b 54 24 10	 mov	 edx, DWORD PTR _input$[esp+24]
  00110	75 08		 jne	 SHORT $LN19@main
  00112	0f bc c2	 bsf	 eax, edx
  00115	74 0a		 je	 SHORT $LN17@main
  00117	83 c0 20	 add	 eax, 32			; 00000020H
$LN19@main:
  0011a	b9 01 00 00 00	 mov	 ecx, 1
  0011f	eb 02		 jmp	 SHORT $LN15@main
$LN17@main:
  00121	33 c9		 xor	 ecx, ecx
$LN15@main:

; 95   : 	printf( "_BSF64( %llu ): %u (Success=%u)\n", input, result, status );

  00123	51		 push	 ecx
  00124	50		 push	 eax
  00125	52		 push	 edx
  00126	56		 push	 esi
  00127	68 00 00 00 00	 push	 OFFSET $SG46998
  0012c	e8 00 00 00 00	 call	 _printf
  00131	83 c4 14	 add	 esp, 20			; 00000014H

; 96   : #endif
; 97   : 
; 98   : 	return EXIT_SUCCESS;

  00134	33 c0		 xor	 eax, eax
  00136	5e		 pop	 esi

; 99   : }

  00137	83 c4 10	 add	 esp, 16			; 00000010H
  0013a	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.14393.0\ucrt\stdio.h
;	COMDAT _scanf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_scanf	PROC						; COMDAT

; 1275 :     {

  00000	56		 push	 esi

; 1276 :         int _Result;
; 1277 :         va_list _ArgList;
; 1278 :         __crt_va_start(_ArgList, _Format);
; 1279 :         _Result = _vfscanf_l(stdin, _Format, NULL, _ArgList);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Format$[esp]
  00005	6a 00		 push	 0
  00007	e8 00 00 00 00	 call	 ___acrt_iob_func
  0000c	83 c4 04	 add	 esp, 4
  0000f	8d 4c 24 0c	 lea	 ecx, DWORD PTR __Format$[esp+4]
  00013	51		 push	 ecx
  00014	6a 00		 push	 0
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  0001d	ff 70 04	 push	 DWORD PTR [eax+4]
  00020	ff 30		 push	 DWORD PTR [eax]
  00022	e8 00 00 00 00	 call	 ___stdio_common_vfscanf
  00027	83 c4 18	 add	 esp, 24			; 00000018H
  0002a	5e		 pop	 esi

; 1280 :         __crt_va_end(_ArgList);
; 1281 :         return _Result;
; 1282 :     }

  0002b	c3		 ret	 0
_scanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.14393.0\ucrt\stdio.h
;	COMDAT __vfscanf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfscanf_l PROC					; COMDAT

; 1058 :         return __stdio_common_vfscanf(

  00000	ff 74 24 10	 push	 DWORD PTR __ArgList$[esp-4]
  00004	ff 74 24 10	 push	 DWORD PTR __Locale$[esp]
  00008	ff 74 24 10	 push	 DWORD PTR __Format$[esp+4]
  0000c	ff 74 24 10	 push	 DWORD PTR __Stream$[esp+8]
  00010	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	ff 30		 push	 DWORD PTR [eax]
  0001a	e8 00 00 00 00	 call	 ___stdio_common_vfscanf
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 1059 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 1060 :             _Stream, _Format, _Locale, _ArgList);
; 1061 :     }

  00022	c3		 ret	 0
__vfscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.14393.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 949  :     {

  00000	56		 push	 esi

; 950  :         int _Result;
; 951  :         va_list _ArgList;
; 952  :         __crt_va_start(_ArgList, _Format);
; 953  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Format$[esp]
  00005	6a 01		 push	 1
  00007	e8 00 00 00 00	 call	 ___acrt_iob_func
  0000c	83 c4 04	 add	 esp, 4
  0000f	8d 4c 24 0c	 lea	 ecx, DWORD PTR __Format$[esp+4]
  00013	51		 push	 ecx
  00014	6a 00		 push	 0
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001d	ff 70 04	 push	 DWORD PTR [eax+4]
  00020	ff 30		 push	 DWORD PTR [eax]
  00022	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00027	83 c4 18	 add	 esp, 24			; 00000018H
  0002a	5e		 pop	 esi

; 954  :         __crt_va_end(_ArgList);
; 955  :         return _Result;
; 956  :     }

  0002b	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.14393.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00000	ff 74 24 10	 push	 DWORD PTR __ArgList$[esp-4]
  00004	ff 74 24 10	 push	 DWORD PTR __Locale$[esp]
  00008	ff 74 24 10	 push	 DWORD PTR __Format$[esp+4]
  0000c	ff 74 24 10	 push	 DWORD PTR __Stream$[esp+8]
  00010	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	ff 30		 push	 DWORD PTR [eax]
  0001a	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 639  :     }

  00022	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.14393.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 95   :         static unsigned __int64 _OptionsStorage;
; 96   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 97   :     }

  00005	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.14393.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\work\bitscan\bitscan\bitscan.h
_TEXT	SEGMENT
_r$ = -4						; size = 4
_i$ = 8							; size = 4
_m$ = 12						; size = 8
?_InlineBitScanReverse64@@YAEPAI_K@Z PROC		; _InlineBitScanReverse64

; 1371 : {

  00000	51		 push	 ecx

; 1372 : 	register DWORD r;
; 1373 : 	register const BOOLEAN s = _BSR64( &r, m );

  00001	0f bd 44 24 10	 bsr	 eax, DWORD PTR _m$[esp+4]
  00006	74 0f		 je	 SHORT $LN4@InlineBitS

; 1374 : 	return *i = static_cast< bsint_t >( r ), static_cast< unsigned char >( s );

  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR _i$[esp]
  0000c	83 c0 20	 add	 eax, 32			; 00000020H
  0000f	b2 01		 mov	 dl, 1
  00011	89 01		 mov	 DWORD PTR [ecx], eax
  00013	8a c2		 mov	 al, dl

; 1375 : }

  00015	59		 pop	 ecx
  00016	c3		 ret	 0

; 1372 : 	register DWORD r;
; 1373 : 	register const BOOLEAN s = _BSR64( &r, m );

$LN4@InlineBitS:
  00017	0f bd 44 24 0c	 bsr	 eax, DWORD PTR _m$[esp]

; 1374 : 	return *i = static_cast< bsint_t >( r ), static_cast< unsigned char >( s );

  0001c	8b 54 24 08	 mov	 edx, DWORD PTR _i$[esp]
  00020	89 04 24	 mov	 DWORD PTR _r$[esp+4], eax
  00023	8b 0c 24	 mov	 ecx, DWORD PTR _r$[esp+4]
  00026	0f 95 c0	 setne	 al
  00029	89 0a		 mov	 DWORD PTR [edx], ecx

; 1375 : }

  0002b	59		 pop	 ecx
  0002c	c3		 ret	 0
?_InlineBitScanReverse64@@YAEPAI_K@Z ENDP		; _InlineBitScanReverse64
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\work\bitscan\bitscan\bitscan.h
_TEXT	SEGMENT
_i$ = 8							; size = 4
_m$ = 12						; size = 8
?_InlineBitScanForward64@@YAEPAI_K@Z PROC		; _InlineBitScanForward64

; 1364 : 	register DWORD r;
; 1365 : 	register const BOOLEAN s = _BSF64( &r, m );

  00000	0f bc 44 24 08	 bsf	 eax, DWORD PTR _m$[esp-4]
  00005	75 0a		 jne	 SHORT $LN8@InlineBitS
  00007	0f bc 44 24 0c	 bsf	 eax, DWORD PTR _m$[esp]
  0000c	74 0e		 je	 SHORT $LN5@InlineBitS
  0000e	83 c0 20	 add	 eax, 32			; 00000020H
$LN8@InlineBitS:

; 1366 : 	return *i = static_cast< bsint_t >( r ), static_cast< unsigned char >( s );

  00011	8b 4c 24 04	 mov	 ecx, DWORD PTR _i$[esp-4]
  00015	b2 01		 mov	 dl, 1
  00017	89 01		 mov	 DWORD PTR [ecx], eax
  00019	8a c2		 mov	 al, dl

; 1367 : }

  0001b	c3		 ret	 0

; 1364 : 	register DWORD r;
; 1365 : 	register const BOOLEAN s = _BSF64( &r, m );

$LN5@InlineBitS:

; 1366 : 	return *i = static_cast< bsint_t >( r ), static_cast< unsigned char >( s );

  0001c	8b 4c 24 04	 mov	 ecx, DWORD PTR _i$[esp-4]
  00020	32 d2		 xor	 dl, dl
  00022	89 01		 mov	 DWORD PTR [ecx], eax
  00024	8a c2		 mov	 al, dl

; 1367 : }

  00026	c3		 ret	 0
?_InlineBitScanForward64@@YAEPAI_K@Z ENDP		; _InlineBitScanForward64
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.14393.0\um\winnt.h
;	COMDAT __InlineBitScanReverse64
_TEXT	SEGMENT
_Index$ = 8						; size = 4
_Mask$ = 12						; size = 8
__InlineBitScanReverse64 PROC				; COMDAT

; 6354 :     if (_BitScanReverse(Index, (DWORD)(Mask >> 32))) {

  00000	0f bd 44 24 0c	 bsr	 eax, DWORD PTR _Mask$[esp]
  00005	8b 4c 24 04	 mov	 ecx, DWORD PTR _Index$[esp-4]
  00009	89 01		 mov	 DWORD PTR [ecx], eax
  0000b	74 06		 je	 SHORT $LN2@InlineBitS

; 6355 :         *Index += 32;

  0000d	83 01 20	 add	 DWORD PTR [ecx], 32	; 00000020H

; 6356 :         return 1;

  00010	b0 01		 mov	 al, 1

; 6360 :         return 1;
; 6361 :     }
; 6362 : 
; 6363 :     return 0;
; 6364 : }

  00012	c3		 ret	 0
$LN2@InlineBitS:

; 6357 :     }
; 6358 : 
; 6359 :     if (_BitScanReverse(Index, (DWORD)Mask)) {

  00013	0f bd 44 24 08	 bsr	 eax, DWORD PTR _Mask$[esp-4]
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	0f 95 c0	 setne	 al

; 6360 :         return 1;
; 6361 :     }
; 6362 : 
; 6363 :     return 0;
; 6364 : }

  0001d	c3		 ret	 0
__InlineBitScanReverse64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.14393.0\um\winnt.h
;	COMDAT __InlineBitScanForward64
_TEXT	SEGMENT
_Index$ = 8						; size = 4
_Mask$ = 12						; size = 8
__InlineBitScanForward64 PROC				; COMDAT

; 6332 :     if (_BitScanForward(Index, (DWORD)Mask)) {

  00000	0f bc 44 24 08	 bsf	 eax, DWORD PTR _Mask$[esp-4]
  00005	8b 4c 24 04	 mov	 ecx, DWORD PTR _Index$[esp-4]
  00009	89 01		 mov	 DWORD PTR [ecx], eax
  0000b	75 0c		 jne	 SHORT $LN5@InlineBitS

; 6333 :         return 1;
; 6334 :     }
; 6335 : 
; 6336 :     if (_BitScanForward(Index, (DWORD)(Mask >> 32))) {

  0000d	0f bc 44 24 0c	 bsf	 eax, DWORD PTR _Mask$[esp]
  00012	89 01		 mov	 DWORD PTR [ecx], eax
  00014	74 06		 je	 SHORT $LN3@InlineBitS

; 6337 :         *Index += 32;

  00016	83 01 20	 add	 DWORD PTR [ecx], 32	; 00000020H
$LN5@InlineBitS:

; 6338 :         return 1;

  00019	b0 01		 mov	 al, 1

; 6342 : }

  0001b	c3		 ret	 0
$LN3@InlineBitS:

; 6339 :     }
; 6340 : 
; 6341 :     return 0;

  0001c	32 c0		 xor	 al, al

; 6342 : }

  0001e	c3		 ret	 0
__InlineBitScanForward64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\work\bitscan\bitscan\bitscan.h
_TEXT	SEGMENT
_r$ = -4						; size = 4
_i$ = 8							; size = 4
_m$ = 12						; size = 4
?_BitScanReverse@@YAEPAII@Z PROC			; _BitScanReverse

; 846  : {

  00000	51		 push	 ecx

; 847  : 	register unsigned long r;
; 848  : 	register const unsigned char s = _BSR32( &r, m );

  00001	0f bd 44 24 0c	 bsr	 eax, DWORD PTR _m$[esp]

; 849  : 	return *i = static_cast< bsint_t >( r ), s;

  00006	8b 54 24 08	 mov	 edx, DWORD PTR _i$[esp]
  0000a	89 04 24	 mov	 DWORD PTR _r$[esp+4], eax
  0000d	8b 0c 24	 mov	 ecx, DWORD PTR _r$[esp+4]
  00010	0f 95 c0	 setne	 al
  00013	89 0a		 mov	 DWORD PTR [edx], ecx

; 850  : }

  00015	59		 pop	 ecx
  00016	c3		 ret	 0
?_BitScanReverse@@YAEPAII@Z ENDP			; _BitScanReverse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\work\bitscan\bitscan\bitscan.h
_TEXT	SEGMENT
_r$ = -4						; size = 4
_i$ = 8							; size = 4
_m$ = 12						; size = 4
?_BitScanForward@@YAEPAII@Z PROC			; _BitScanForward

; 838  : {

  00000	51		 push	 ecx

; 839  : 	register unsigned long r;
; 840  : 	register const unsigned char s = _BSF32( &r, m );

  00001	0f bc 44 24 0c	 bsf	 eax, DWORD PTR _m$[esp]

; 841  : 	return *i = static_cast< bsint_t >( r ), s;

  00006	8b 54 24 08	 mov	 edx, DWORD PTR _i$[esp]
  0000a	89 04 24	 mov	 DWORD PTR _r$[esp+4], eax
  0000d	8b 0c 24	 mov	 ecx, DWORD PTR _r$[esp+4]
  00010	0f 95 c0	 setne	 al
  00013	89 0a		 mov	 DWORD PTR [edx], ecx

; 842  : }

  00015	59		 pop	 ecx
  00016	c3		 ret	 0
?_BitScanForward@@YAEPAII@Z ENDP			; _BitScanForward
_TEXT	ENDS
END
